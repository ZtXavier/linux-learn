能否搞懂 Hello World 程序的一生？

1，程序是怎么变成 a.out 的？（编译原理，ELF格式，程序员的自我修养）
A:程序是先通过.c文件通过预处理(处理define等等-E)->编译(将代码变为汇编代码)->汇编(将汇编代码转变为二进制文件)->链接(加载链接库等操作)->可执行文件a.out 

google:预处理(宏替换,删除注释,扩展包含的文件)生成.i文件->主要对代码进行解析，分析出语法错误词法错误，并且符号汇总。这一阶段完成后会形成.s文件，并且将c代码转成汇编语言->
在这一阶段，会形成符号表。并且将汇编代码转换成机器指令，二进制序列->链接这一阶段主要是合并段表，合并符号表和对符号表的重定位,编译阶段结束后，会生成一个a.out的文件，
这个就是我们说的可执行程序，中间产生的.i .s .o文件会被自动删除（可使用如上代码保留）


2，什么是链接？这个程序需要链接吗？int main() {}  为什么？
链接我认为是当运行一段程序时将调取我们定义在其他源文件的函数文件插入当前执行的代码段中,int main(){}这个程序不需要链接,因为这个程序是操作系统在程序段中运行的代码段

3，a.out 怎么被加载进内存执行的，为什么 windows 上的文件在 linux 上无法执行。
4，cpu 眼里看到了什么，cpu 是怎么取数据的？（微机原理）
5，cpu 从哪里取数据，cpu 取不到了会怎么样（L1~L3 cache）
6，执行过程 cpu 需要访问内存，中间 mmu 是干嘛的？什么是 tlb。
7，进程需要申请内存，调用 malloc，后面发生了什么？（虚拟内存管理机制）
8，7 的情况下，swap 是否配置有什么影响。（中断和缺页异常）
9，程序使用了 write(2)，是怎么调用的？(系统调用的原理，cpu 运行等级)
10，数据写入磁盘的过程经历了哪些组件和阶段？（pagecache）
